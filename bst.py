# -*- coding: utf-8 -*-


class BinaryNode(object):
  """Implements a node of a binary search tree in Python.

  Any binary search tree, by means of recursion, can be fully specified using
  its root BinaryNode. An empty BST can be represented using, simply, None.

  This BST does not do any kind of balancing, and thus can degenerate into a
  linked list in the worst case.

  This BST also does NOT permit duplicates.

  Attrs:
    value: The datum held by the node.
    left: The left child of this node (or None, if node has no left child).
    right: The right child of this node (or None, if node has no right child).
    _size: The size of the BST of which this node is the root.
  """
  def __init__(self, value):
    self.value = value
    self.left = None
    self.right = None
    self._size = 1

  @classmethod
  def build(cls, *data):
    """Creates BST from a list of data to be inserted in order.

    Returns the root BinaryNode of the new BST, or None if data was empty.
    """
    if not data:
      return None
    root = cls(data[0])
    root.insert(data[1:])
    return root

  def delete(self, value):
    """Deletes a given value from the tree if it exists.

    If necessary, the root of the tree is updated (e.g., if it was the root
    which was deleted).

    Returns True if the value was successfully deleted, False if it wasn't found
    in the BST.
    """
    self._root, result = self.__delete(value, self._root)
    return result

  @property
  def inorder(self):
    """Returns values of BST's nodes in order, as a list."""
    return self.__inorder(self)

  def insert(self, value):
    """Inserts a new value into the BST (without rebalancing the tree).

    Returns True if the value was successfully inserted, False otherwise (e.g.,
    probably because the value duplicated an existing value in the BST).
    """
    result = self.__insert(value, self)
    self._size += int(result)
    return result

  @property
  def postorder(self):
    """Returns list of values generated by postorder traversal of tree."""
    return self.__postorder(self)

  @property
  def preorder(self):
    """Returns list of values generated by preorder traversal of tree."""
    return self.__preorder(self)

  def search(self, value):
    """Returns True if value is found in BST, False otherwise."""
    return self.__search(value, self._root)

  @property
  def size(self):
    """Returns the number of elements in the BST as an int."""
    return self._size

  def __delete(self, value, root):
    """Deletes a given value from the given subtreeree if it exists.

    Returns True if the value was successfully deleted, False if it wasn't
    found in the BST.
    """
    if not root:
      return False
    if value < root.value:
      return
    return self.__delete(value, self._root)

  def __inorder(self, root):
    """Returns values of all nodes in a subtree in order, as a list.

    For an empty subtree (defined by a root of None), this returns an empty
    list.
    """
    if not root:
      return []
    return self.__inorder(root.left) + [root.value] + self.__inorder(root.right)

  def __insert(self, value, root):
    """Attempts to insert the given value into the subtree with the given root.

    Returns True if the value was successfully inserted, False otherwise (e.g.,
    probably because the value duplicated an existing value in the BST).
    """
    if not root:
      return self._Node(value), True

    if value < root.value:
      root.left, result = self.__insert(value, root.left)
      return root, result

    if value > root.value:
      root.right, result = self.__insert(value, root.right)
      return root, result

    return root, False

  def __postorder(self, root):
    """Returns list of values generated by postorder traversal of a subtree.

    For an empty subtree, this returns an empty list.
    """
    if not root:
      return []
    return (
      self.__postorder(root.left) + self.__postorder(root.right) + [root.value])

  def __preorder(self, root):
    """Returns list of values generated by preorder traversal of a subtree.

    For an empty subtree, this returns an empty list.
    """
    if not root:
      return []
    return (
      [root.value] + self.__preorder(root.left) + self.__preorder(root.right))

  def __search(self, value, root):
    """Returns True if value is found in subtree, False otherwise."""
    if not root:
      return False
    if value < root.value:
      return self.__search(value, root.left)
    if value > root.value:
      return self.__search(value, root.right)
    return True
